<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Breeze.ContextProvider.NH</name>
    </assembly>
    <members>
        <member name="T:Breeze.ContextProvider.NH.BreezeNHControllerAttribute">
            <summary>
            Configure the Web API settings for this Breeze Controller
            </summary>
            <remarks>
            Clears all <see cref="T:System.Net.Http.Formatting.MediaTypeFormatter"/>s and 
            adds the Breeze formatter for JSON content.
            Removes the competing ASP.NET Web API's QueryFilterProvider if present. 
            Adds <see cref="T:Breeze.WebApi2.EnableBreezeQueryFilterProvider"/> for OData query processing
            Adds <see cref="T:Breeze.ContextProvider.NH.MetadataFilterProvider"/> returning a Metadata action filter
            which (by default) converts a Metadata string response to
            an HTTP response with string content.
            </remarks>
        </member>
        <member name="M:Breeze.ContextProvider.NH.BreezeNHControllerAttribute.Initialize(System.Web.Http.Controllers.HttpControllerSettings,System.Web.Http.Controllers.HttpControllerDescriptor)">
            <summary>
            Initialize the Breeze controller with a single <see cref="T:System.Net.Http.Formatting.MediaTypeFormatter"/> for JSON
            and a single <see cref="T:System.Web.Http.Filters.IFilterProvider"/> for Breeze OData support
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.BreezeNHControllerAttribute.MaxExpansionDepth">
            <summary>
            Gets or sets max expansion depth at controller level
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.BreezeNHControllerAttribute.EnsureStableOrdering">
            <summary>
            Gets or sets a value indicating whether query composition should
            alter the original query when necessary to ensure a stable sort order.
            </summary>
            <value>A <c>true</c> value indicates the original query should
            be modified when necessary to guarantee a stable sort order.
            A <c>false</c> value indicates the sort order can be considered
            stable without modifying the query.  Query providers that ensure
            a stable sort order should set this value to <c>false</c>.
            The default value is <c>true</c>.</value>
        </member>
        <member name="P:Breeze.ContextProvider.NH.BreezeNHControllerAttribute.HandleNullPropagation">
            <summary>
            Gets or sets a value indicating how null propagation should
            be handled during query composition. 
            </summary>
            <value>
            The default is <see cref="F:System.Web.Http.OData.Query.HandleNullPropagationOption.Default"/>.
            </value>
        </member>
        <member name="P:Breeze.ContextProvider.NH.BreezeNHControllerAttribute.MaxAnyAllExpressionDepth">
            <summary>
            Gets or sets the maximum depth of the Any or All elements nested inside the query.
            </summary>
            <remarks>
            This limit helps prevent Denial of Service attacks. The default value is 1.
            </remarks>
            <value>
            The maxiumum depth of the Any or All elements nested inside the query.
            </value>
        </member>
        <member name="P:Breeze.ContextProvider.NH.BreezeNHControllerAttribute.PageSize">
            <summary>
            Gets or sets the maximum number of query results to send back to clients.
            </summary>
            <value>
            The maximum number of query results to send back to clients.
            </value>
        </member>
        <member name="M:Breeze.ContextProvider.NH.BreezeNHControllerAttribute.GetQueryableFilterProvider(Breeze.ContextProvider.NH.BreezeNHQueryableAttribute)">
            <summary>
            Return the IQueryable <see cref="T:System.Web.Http.Filters.IFilterProvider"/> for a Breeze Controller
            </summary>
            <remarks>
            By default returns an <see cref="T:Breeze.WebApi2.EnableBreezeQueryFilterProvider"/>.
            Override to substitute a custom provider.
            </remarks>
        </member>
        <member name="M:Breeze.ContextProvider.NH.BreezeNHControllerAttribute.GetJsonFormatter(System.Web.Http.Controllers.HttpControllerSettings,System.Web.Http.HttpConfiguration)">
            <summary>
            Return the Breeze-specific <see cref="T:System.Net.Http.Formatting.MediaTypeFormatter"/> that formats
            content to JSON. This formatter must be tailored to work with Breeze clients. 
            </summary>
            <remarks>
            By default returns the Breeze <see cref="T:Breeze.WebApi2.JsonFormatter"/>.
            Override it to substitute a custom JSON formatter.
            </remarks>
        </member>
        <member name="M:Breeze.ContextProvider.NH.BreezeNHControllerAttribute.GetMetadataFilterProvider(Breeze.WebApi2.MetadataToHttpResponseAttribute)">
            <summary>
            Return the Metadata <see cref="T:System.Web.Http.Filters.IFilterProvider"/> for a Breeze Controller
            </summary>
            <remarks>
            By default returns an <see cref="T:Breeze.WebApi2.MetadataToHttpResponseAttribute"/>.
            Override to substitute a custom provider.
            </remarks>
        </member>
        <member name="T:Breeze.ContextProvider.NH.BreezeNHQueryableAttribute">
            <summary>
            Override the EnableBreezeQueryAttribute to use NHQueryHelper, which applies OData syntax to NHibernate queries.
            Use this attribute on each method in your WebApi controller that uses Nhibernate's IQueryable.
            <see cref="!:http://www.breezejs.com/sites/all/apidocs/classes/EntityQuery.html#method_expand"/>
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.BreezeNHQueryableAttribute.#ctor">
            <summary>
            Sets HandleNullPropagation = false on the base class.  Otherwise it's true for non-EF, and that
            complicates the query expressions and breaks NH's query parser.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.BreezeNHQueryableAttribute.GetQueryHelper(System.Net.Http.HttpRequestMessage)">
            <summary>
            Get the QueryHelper instance for the current request.  We use a single instance per request because
            QueryHelper is stateful, and may preserve state between the ApplyQuery and OnActionExecuted methods.
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.BreezeNHQueryableAttribute.ApplyQuery(System.Linq.IQueryable,System.Web.Http.OData.Query.ODataQueryOptions)">
            <summary>
            All standard OData web api support is handled here (except select and expand).
            This method also handles nested orderby statements the the current ASP.NET web api does not yet support.
            This method is called by base.OnActionExecuted
            </summary>
            <param name="queryable"></param>
            <param name="queryOptions"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.Extensions.MemberInfoExtensions.GetMemberUnderlyingType(System.Reflection.MemberInfo)">
            <summary>
            Gets the member's underlying type.
            </summary>
            <param name="member">The member.</param>
            <returns>The underlying type of the member.</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.Extensions.MemberInfoExtensions.CanReadMemberValue(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Determines whether the specified MemberInfo can be read.
            </summary>
            <param name="member">The MemberInfo to determine whether can be read.</param>
            /// <param name="nonPublic">if set to <c>true</c> then allow the member to be gotten non-publicly.</param>
            <returns>
            	<c>true</c> if the specified MemberInfo can be read; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.Extensions.MemberInfoExtensions.CanSetMemberValue(System.Reflection.MemberInfo,System.Boolean,System.Boolean)">
            <summary>
            Determines whether the specified MemberInfo can be set.
            </summary>
            <param name="member">The MemberInfo to determine whether can be set.</param>
            <param name="nonPublic">if set to <c>true</c> then allow the member to be set non-publicly.</param>
            <param name="canSetReadOnly">if set to <c>true</c> then allow the member to be set if read-only.</param>
            <returns>
            	<c>true</c> if the specified MemberInfo can be set; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.Extensions.TypeExtensions.GetDefaultValue(System.Type)">
            <summary>
            http://stackoverflow.com/questions/2490244/default-value-of-a-type-at-runtime
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.Json.CustomMemberValueProvider.SetValue(System.Object,System.Object)">
            <summary>
            Not supported
            </summary>
            <param name="target"></param>
            <param name="value"></param>
        </member>
        <member name="T:Breeze.ContextProvider.NH.NHibernateProxyJsonConverter">
            <summary>
            JsonConverter for handling NHibernate proxies.  
            Only serializes the object if it is initialized, i.e. the proxied object has been loaded.
            </summary>
            <see cref="!:http://james.newtonking.com/projects/json/help/html/T_Newtonsoft_Json_JsonConverter.htm"/>
        </member>
        <member name="T:Breeze.ContextProvider.NH.NHIncludingContractResolver">
            <summary>
            Newtonsoft.Json ContractResolver that can be configured to include properties by name.
            Allows JSON serializer to skip certain properties, thus preventing the serializer from trying to 
            serialize the entire object graph.
            Uses the ClassMetaData from the SessionFactory to determine which types should be serialized by default.
            Excludes association properties by default, unless explicitly included.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHIncludingContractResolver.#ctor(NHibernate.ISessionFactory,System.String[])">
            <summary>
            Configure the included property names using an array of strings
            </summary>
            <param name="includedMembers">Names of properties to be included</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHIncludingContractResolver.#ctor(NHibernate.ISessionFactory,System.Collections.Generic.IDictionary{System.Type,System.Collections.Generic.List{System.String}})">
            <summary>
            Configure the included property names using a dictionary of { Type -> List of property names to include }
            </summary>
            <param name="includedTypeMembers"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHIncludingContractResolver.GetSerializableMembers(System.Type)">
            <summary>
            Returns the list of property and field names that should be serialized on a given type.
            </summary>
            <param name="objectType"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHIncludingContractResolver.IsIncluded(NHibernate.Metadata.IClassMetadata,System.Type,System.Type,System.String)">
            <summary>
            For a given property type, containing type, and property name, return true if it should
            be serialized and false if not.  By default, value types and system types are serialized,
            but collections and custom types are not.
            </summary>
            <param name="meta"></param>
            <param name="propertyType"></param>
            <param name="containingType"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Breeze.ContextProvider.NH.ExcludingContractResolver">
            <summary>
            Newtonsoft.Json ContractResolver that can be configured to exclude certain properties by name.
            Allows JSON serializer to skip certain properties, thus preventing the serializer from trying to 
            serialize the entire object graph.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.ExcludingContractResolver.#ctor(System.String[])">
            <summary>
            Define the properties that should be excluded.  Two different methods can be used: 
            1. The simple property name, e.g. "Orders".  This will exclude properties with that name from anywhere in the object graph.
            2. The declaring type name + '.' + property name, e.g. "Customer.Orders".  This will exclude the property name from that type only.
            </summary>
            <param name="excludedMembers"></param>
        </member>
        <member name="T:Breeze.ContextProvider.NH.IncludingContractResolver">
            <summary>
            Newtonsoft.Json ContractResolver that can be configured to include properties by name.
            Allows JSON serializer to skip certain properties, thus preventing the serializer from trying to 
            serialize the entire object graph.
            Serializes value types and System types by default, but excludes all collections and other
            types unless explicitly included.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.IncludingContractResolver.#ctor(System.String[])">
            <summary>
            Configure the included property names using an array of strings
            </summary>
            <param name="includedMembers">Names of properties to be included</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.IncludingContractResolver.#ctor(System.Collections.Generic.IDictionary{System.Type,System.Collections.Generic.List{System.String}})">
            <summary>
            Configure the included property names using a dictionary of { Type -> List of property names to include }
            </summary>
            <param name="includedTypeMembers"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.IncludingContractResolver.GetSerializableMembers(System.Type)">
            <summary>
            Returns the list of property and field names that should be serialized on a given type.
            </summary>
            <param name="objectType"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.IncludingContractResolver.IsIncluded(System.Type,System.Type,System.String)">
            <summary>
            For a given property type, containing type, and property name, return true if it should
            be serialized and false if not.  By default, value types and system types are serialized,
            but collections and custom types are not.
            </summary>
            <param name="propertyType"></param>
            <param name="containingType"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Breeze.ContextProvider.NH.NHibernateContractResolver">
            <summary>
            Newtonsoft.Json ContractResolver for NHibernate objects.
            Allows JSON serializer to skip properties that are not already resolved, thus preventing the 
            serializer from trying to serialize the entire object graph.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHibernateContractResolver.CreateProperties(System.Type,Newtonsoft.Json.MemberSerialization)">
            <summary>
            Creates properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract"/>.
            </summary>
            <param name="type">The type to create properties for.</param>
            /// <param name="memberSerialization">The member serialization mode for the type.</param>
            <returns>Properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract"/>.</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHibernateContractResolver.CreateProperty(System.Type,System.Reflection.MemberInfo,Newtonsoft.Json.MemberSerialization)">
            <summary>
            Control serialization NHibernate entities by using JsonProperty.ShouldSerialize.
            Serialization should only be attempted on properties that are initialized.
            </summary>
            <param name="member"></param>
            <param name="memberSerialization"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Breeze.ContextProvider.NH.TypeContractResolver">
            <summary>
            Newtonsoft.Json ContractResolver that only includes certain types from a given assembly.
            All other types from that assembly are excluded.  This allows control over which custom
            types are serialized.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.TypeContractResolver.#ctor(System.Type[])">
            <summary>
            Define included types.  All other types from the same assembly as the first type will be excluded.
            </summary>
            <param name="includedTypes"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.TypeContractResolver.#ctor(System.Reflection.Assembly,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Define the assembly and the included types.  All other types from the assembly will be excluded.
            </summary>
            <param name="entityAssembly"></param>
            <param name="includedTypes"></param>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.BaseProperty.Name">
            <summary>
            The client side name of this property.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.BaseProperty.NameOnServer">
            <summary>
            The server side side name of this property. Either name or nameOnServer must be specified and either is sufficient.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.ComplexType.IsComplexType">
            <summary>
            This must be 'true'.  This field is what distinguishes an entityType from a complexType. 
            </summary>
        </member>
        <member name="T:Breeze.ContextProvider.NH.Metadata.DataProperty">
            <summary>
            A single data property, at a minimum you must to define either a 'name' or a 'nameOnServer' and either a 'dataType' or a 'complexTypeName'.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataProperty.DataType">
            <summary>
            If present, the complexType name should be omitted.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataProperty.ComplexTypeName">
            <summary>
            If present, this must be the fully qualified name of one of the 'complexTypes' defined within this document, and the 'dataType' property may be omitted
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataProperty.IsNullable">
            <summary>
            Whether a null can be assigned to this property.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataProperty.DefaultValue">
            <summary>
            The default value for this property if nothing is assigned to it.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataProperty.IsPartOfKey">
            <summary>
            Whether this property is part of the key for this entity type
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataProperty.ConcurrencyMode">
            <summary>
            This determines whether this property is used for concurreny purposes.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataProperty.MaxLength">
            <summary>
            Only applicable to 'String' properties. This is the maximum string length allowed.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataProperty.Validators">
            <summary>
            A list of the validators (validations) that will be associated with this property
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataService.AdapterName">
            <summary>
            On deserialization, this must match the name of some 'dataService adapter' already registered on the breeze client.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataService.HasServerMetadata">
            <summary>
            Whether the server can provide metadata for this service.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataService.JsonResultsAdapter">
            <summary>
            On deserialization, this must match the name of some jsonResultsAdapter registered on the breeze client.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataService.UseJsonp">
            <summary>
            Whether to use JSONP when performing a 'GET' request against this service.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.DataService.UriBuilderName">
            <summary>
            The name of the uriBuilder to be used with this service.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.EntityType.AutoGeneratedKeyType">
            <summary>
            Defines the mechanism by which the key for entities of this type are determined on the server.  'None' means that the client sets the key.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.EntityType.DefaultResourceName">
            <summary>
            The default name by which entities of this type will be queried.  Multipe 'resourceNames' may query for the same entityType, (see the 'resourceEntityTypeMap') but only one is the default.
            </summary>
        </member>
        <member name="T:Breeze.ContextProvider.NH.Metadata.MetadataSchema">
            <summary>
            Metadata describing the entity model.  Converted to JSON to send to Breeze client.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.MetadataSchema.MetadataVersion">
            <summary>
            The serialization version for this document
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.MetadataSchema.NamingConvention">
            <summary>
            On deserialization, this must match the name of some 'namingConvention' already registered on the breeze client.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.MetadataSchema.LocalQueryComparisonOptions">
            <summary>
            On deserialization, this must match the name of some 'localQueryComparisonOptions' already registered on the breeze client.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.MetadataSchema.StructuralTypes">
            <summary>
            Array of entity type/complex type names to their metadata definitions.  The key is a structural type name and the value is either an entityType or a complexType
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.MetadataSchema.ResourceEntityTypeMap">
            <summary>
            Map of resource names to entity type names.
            </summary>
        </member>
        <member name="F:Breeze.ContextProvider.NH.Metadata.MetadataSchema.ForeignKeyMap">
            <summary>
            Map of relationship name -> foreign key name, e.g. "Customer" -> "CustomerID".
            Used for re-establishing the entity relationships from the foreign key values during save.
            This part is not sent to the client because it is separate from the base dictionary implementation.
            </summary>
        </member>
        <member name="T:Breeze.ContextProvider.NH.Metadata.NavigationProperty">
            <summary>
            A single navigation property, at a minimum you must to define the 'required' properties defined below AS WELL AS either a 'name' or a 'nameOnServer'..
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.NavigationProperty.EntityTypeName">
            <summary>
            The type of the entity or collection of entities returned by this property.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.NavigationProperty.IsScalar">
            <summary>
            Whether this property returns a single entity (true) or an array of entities (false).
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.NavigationProperty.AssociationName">
            <summary>
            An arbitrary name that is used to link this navigation property to its inverse property. For bidirectional navigations this name will occur twice within this document, otherwise only once.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.NavigationProperty.ForeignKeyNames">
            <summary>
            An array of the names of the properties on this type that are the foreign key 'backing' for this navigation property.  This may only be set if 'isScalar' is true.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.NavigationProperty.ForeignKeyNamesOnServer">
            <summary>
            Same as ForeignKeyNames, but the names here are server side names as opposed to client side.  Only one or the other is needed.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.NavigationProperty.Validators">
            <summary>
            A list of the validators (validations) that will be associated with this property
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.StructuralType.ShortName">
            <summary>
            Together the shortName and the namespace make up a fully qualified name.  Within this metadata references to an entityType are all qualified references. See the 'structuralTypeName' definition.instanceof in this document.
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.StructuralType.Validators">
            <summary>
            A list of the validators (validations) that will be associated with this structure
            </summary>
        </member>
        <member name="P:Breeze.ContextProvider.NH.Metadata.Validator.Name">
            <summary>
            On deserialization, this must match the name of some validator already registered on the breeze client.
            </summary>
        </member>
        <member name="T:Breeze.ContextProvider.NH.NHBreezeMetadata">
            <summary>
            Builds a data structure containing the metadata required by Breeze.
            <see cref="!:http://www.breezejs.com/documentation/breeze-metadata-format"/>
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.BuildMetadata">
            <summary>
            Build the Breeze metadata as a nested Dictionary.  
            The result can be converted to JSON and sent to the Breeze client.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.InitMap">
            <summary>
            Populate the metadata header.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.AddClass(NHibernate.Metadata.IClassMetadata)">
            <summary>
            Add the metadata for an entity.
            </summary>
            <param name="meta"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.AddClassProperties(NHibernate.Metadata.IClassMetadata,NHibernate.Mapping.PersistentClass,System.Collections.Generic.List{System.Collections.Generic.Dictionary{System.String,System.Object}},System.Collections.Generic.List{System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Add the properties for an entity.
            </summary>
            <param name="meta"></param>
            <param name="pClass"></param>
            <param name="dataList">will be populated with the data properties of the entity</param>
            <param name="navList">will be populated with the navigation properties of the entity</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.AddComponent(NHibernate.Type.ComponentType,System.Collections.Generic.List{NHibernate.Mapping.ISelectable})">
            <summary>
            Adds a complex type definition
            </summary>
            <param name="compType">The complex type</param>
            <param name="propColumns">The columns which the complex type spans.  These are used to get the length and defaultValues</param>
            <returns>The class name and namespace in the form "Location:#Breeze.Nhibernate.NorthwindIBModel"</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.MakeDataProperty(System.String,System.String,System.Boolean,NHibernate.Mapping.Column,System.Boolean,System.Boolean)">
            <summary>
            Make data property metadata for the entity
            </summary>
            <param name="propName">name of the property on the server</param>
            <param name="typeName">data type of the property, e.g. Int32</param>
            <param name="isNullable">whether the property is nullable in the database</param>
            <param name="col">Column object, used for maxLength and defaultValue</param>
            <param name="isKey">true if this property is part of the key for the entity</param>
            <param name="isVersion">true if this property contains the version of the entity (for a concurrency strategy)</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.MakeAssociationProperty(System.Type,NHibernate.Type.IAssociationType,System.String,System.String,NHibernate.Mapping.PersistentClass,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Object}},System.Boolean)">
            <summary>
            Make association property metadata for the entity.
            Also populates the _fkMap which is used for related-entity fixup in NHContext.FixupRelationships
            </summary>
            <param name="propType"></param>
            <param name="propName"></param>
            <param name="pClass"></param>
            <param name="relatedDataPropertyMap"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.GetPropertyColumnNames(NHibernate.Persister.Entity.AbstractEntityPersister,System.String)">
            <summary>
            Get the column names for a given property as a comma-delimited string of unbracketed names.
            </summary>
            <param name="persister"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.UnBracket(System.String)">
            <summary>
            Get the column name without square brackets or quotes around it.  E.g. "[OrderID]" -> OrderID 
            Because sometimes Hibernate gives us brackets, and sometimes it doesn't.
            Double-quotes happen with SQL CE.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.GetEntityType(System.Type,System.Boolean)">
            <summary>
            Get the Breeze name of the entity type.
            For collections, Breeze expects the name of the element type.
            </summary>
            <param name="type"></param>
            <param name="isCollectionType"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.Pluralize(System.String)">
            <summary>
            lame pluralizer.  Assumes we just need to add a suffix.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHBreezeMetadata.GetAssociationName(System.String,System.String,System.Boolean)">
            <summary>
            Creates an association name from two entity names.
            For consistency, puts the entity names in alphabetical order.
            </summary>
            <param name="name1"></param>
            <param name="name2"></param>
            <param name="isOneToOne">if true, adds the one-to-one suffix</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.#ctor(NHibernate.ISession,Breeze.ContextProvider.NH.IBreezeConfigurator)">
            <summary>
            Create a new context for the given session.  
            Each thread should have its own NHContext and Session.
            </summary>
            <param name="session">Used for queries and updates</param>
            <param name="breezeConfigurator">Used for get configurations</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.#ctor(Breeze.ContextProvider.NH.NHContext)">
            <summary>
            Creates a new context using the session and metadata from the sourceContext
            </summary>
            <param name="sourceContext">source of the Session and metadata used by this new context.</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.GetQuery``1(System.Boolean)">
            <summary>
            Return a query for the given entity
            </summary>
            <typeparam name="T">Entity type</typeparam>
            <param name="cacheable">Whether to mark the query Cacheable.  Default is false.</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.GetQuery``1(System.String)">
            <summary>
            Return a cacheable query for the given entity, using the given cache region
            </summary>
            <typeparam name="T">Entity type</typeparam>
            <param name="cacheRegion">Cache region to use.</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.Close">
            <summary>
            Close the session
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.Dispose">
            <summary>
            Close the session
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.GetDbConnection">
            <returns>The connection from the session.</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.CloseDbConnection">
            <summary>
            Close the session and its associated db connection
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.BeforeSaveEntityGraph(System.Collections.Generic.List{Breeze.ContextProvider.EntityInfo})">
            <summary>
            Allows subclasses to process entities before they are saved.  This method is called
            after BeforeSaveEntities(saveMap), and before any session.Save methods are called.
            The foreign-key associations on the entities have been resolved, relating the entities
            to each other, and attaching proxies for other many-to-one associations.
            </summary>
            <param name="entitiesToPersist">List of entities in the order they will be saved</param>
            <returns>The same entitiesToPersist.  Overrides of this method may modify the list.</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.BeforeSaveEntity(Breeze.ContextProvider.EntityInfo)">
            <summary>
            If TypeFilter function is defined, returns TypeFilter(entityInfo.Entity.GetType())
            </summary>
            <param name="entityInfo"></param>
            <returns>true if the entity should be saved, false if not</returns>
        </member>
        <member name="P:Breeze.ContextProvider.NH.NHContext.TypeFilter">
            <summary>
            Sets a function to filter types from metadata generation and SaveChanges.
            The function returns true if a Type should be included, false otherwise.
            </summary><example>
            // exclude the LogRecord entity
            MyNHContext.TypeFilter = (type) => type.Name != "LogRecord";
            </example><example>
            // exclude certain entities, and all Audit* entities
            var excluded = new string[] { "Comment", "LogRecord", "UserPermission" };
            MyNHContext.TypeFilter = (type) =>
            {
              if (excluded.Contains(type.Name)) return false;
              if (type.Name.StartsWith("Audit")) return false;
              return true;
            };
            </example>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.SaveChangesCore(Breeze.ContextProvider.SaveWorkState)">
            <summary>
            Persist the changes to the entities in the saveMap.
            This implements the abstract method in ContextProvider.
            Assigns saveWorkState.KeyMappings, which map the temporary keys to their real generated keys.
            Note that this method sets session.FlushMode = FlushMode.Never, so manual flushes are required.
            </summary>
            <param name="saveMap">Map of Type -> List of entities of that type</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.GetRelationshipFixer(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{Breeze.ContextProvider.EntityInfo}})">
            <summary>
            Get a new NHRelationshipFixer using the saveMap and the foreign-key map from the metadata.
            </summary>
            <param name="saveMap"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.AddKeyMappings(System.Collections.Generic.List{Breeze.ContextProvider.EntityInfo})">
            <summary>
            Add key mappings for entities in the saveOrder.
            </summary>
            <param name="saveOrder"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.ProcessSaves(System.Collections.Generic.List{Breeze.ContextProvider.EntityInfo})">
            <summary>
            Persist the changes to the entities in the saveOrder.
            </summary>
            <param name="saveOrder"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.ProcessSavesAsync(System.Collections.Generic.List{Breeze.ContextProvider.EntityInfo})">
            <summary>
            Persist the changes to the entities in the saveOrder.
            </summary>
            <param name="saveOrder"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.ProcessEntity(Breeze.ContextProvider.EntityInfo,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Add, update, or delete the entity according to its EntityState.
            </summary>
            <param name="entityInfo"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.ProcessEntityAsync(Breeze.ContextProvider.EntityInfo,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Add, update, or delete the entity according to its EntityState.
            </summary>
            <param name="entityInfo"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.RestoreOldVersionValue(Breeze.ContextProvider.EntityInfo,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Restore the old value of the concurrency column so Hibernate will save the entity.
            Otherwise it will complain because Breeze has already changed the value.
            </summary>
            <param name="entityInfo"></param>
            <param name="classMeta"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.AddKeyMapping(Breeze.ContextProvider.EntityInfo,System.Type,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Record the value of the temporary key in EntityKeyMapping
            </summary>
            <param name="entityInfo"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.GetIdentifier(System.Object,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Get the identifier value for the entity.  If the entity does not have an
            identifier property, or natural identifiers defined, then the entity itself is returned.
            </summary>
            <param name="entity"></param>
            <param name="meta"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.GetIdentifierAsArray(System.Object,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Get the identier value for the entity as an object[].
            This is needed for creating an EntityError.
            </summary>
            <param name="entity"></param>
            <param name="meta"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.UpdateAutoGeneratedKeys(System.Collections.Generic.List{Breeze.ContextProvider.EntityInfo})">
            <summary>
            Update the KeyMappings with their real values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.RefreshFromSession(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{Breeze.ContextProvider.EntityInfo}})">
            <summary>
            Refresh the entities from the database.  This picks up changes due to triggers, etc.
            </summary>
            <param name="saveMap"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.RefreshFromSessionAsync(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{Breeze.ContextProvider.EntityInfo}})">
            <summary>
            Refresh the entities from the database.  This picks up changes due to triggers, etc.
            </summary>
            <param name="saveMap"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHContext.GetProxyRealType(System.Object)">
            <summary>
            Custom function to get the real entity type as NHibernateUtil.GetClass returns wrong types
            </summary>
            <param name="proxy"></param>
            <returns></returns>
        </member>
        <member name="T:Breeze.ContextProvider.NH.NHEagerFetch">
            <summary>
            Converts OData-style $expand clauses into NHibernate Fetch commands.
            Adapted from NhQueryableEnumeratorAttribute.cs found in https://github.com/PeteGoo/NHibernate.QueryService
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHEagerFetch.ApplyExpansions(System.Linq.IQueryable,System.String,Breeze.ContextProvider.NH.ExpandTypeMap,System.Boolean)">
            <summary>
            Add the Fetch clauses to the query according to the given expand paths
            </summary>
            <param name="queryable">The query to expand</param>
            <param name="expandsQueryString">Comma-separated list of properties to expand.  May include nested paths of the form "Property/SubProperty"</param>
            <param name="sessionFactory">Provides the NHibernate metadata for the classes</param>
            <param name="expandMap">Will be populated with the names of the expanded properties for each type.</param>
            <param name="expandCollections">If true, eagerly fetch collections. Caution: this causes problems with $skip and $top operations.  
                Default is false.  expandMap will still be populated with the collection property, so it will be lazy loaded.
                Be sure to set default_batch_fetch_size in the configuration for lazy loaded collections.</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHEagerFetch.ApplyExpansions(System.Linq.IQueryable,System.String[],Breeze.ContextProvider.NH.ExpandTypeMap,System.Boolean)">
            <summary>
            Add the Fetch clauses to the query according to the given expand paths
            </summary>
            <param name="queryable">The query to expand</param>
            <param name="expandPaths">The names of the properties to expand.  May include nested paths of the form "Property/SubProperty"</param>
            <param name="sessionFactory">Provides the NHibernate metadata for the classes</param>
            <param name="expandMap">Will be populated with the names of the expanded properties for each type.</param>
            <param name="expandCollections">If true, eagerly fetch collections. Caution: this causes problems with $skip and $top operations.  
                Default is false.  expandMap will still be populated with the collection property, so it will be lazy loaded.
                Be sure to set default_batch_fetch_size in the configuration for lazy loaded collections.</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHEagerFetch.MapExpansions(System.Type,System.String[])">
            <summary>
            Create an ExpandTypeMap populated according to the expandPaths.
            </summary>
            <param name="type">The type of the root element.</param>
            <param name="expandPaths">The names of the properties to expand.  May include nested paths of the form "Property/SubProperty"</param>
            <returns>expandMap</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHEagerFetch.MapExpansions(System.Type,System.String[],Breeze.ContextProvider.NH.ExpandTypeMap)">
            <summary>
            Create an ExpandTypeMap populated according to the expandPaths.
            </summary>
            <param name="type">The type of the root element.</param>
            <param name="expandPaths">The names of the properties to expand.  May include nested paths of the form "Property/SubProperty"</param>
            <param name="expandMap">Will be populated with the names of the expanded properties for each type.  If null, a new one is created.</param>
            <returns>expandMap</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHEagerFetch.ApplyExpansions(NHibernate.ICriteria,System.String[],NHibernate.ISessionFactory,System.Collections.Generic.IDictionary{System.Type,System.Collections.Generic.List{System.String}})">
            <summary>
            Add the Fetch clauses to the query according to the given expand paths, using the ICriteria API
            </summary>
            <param name="criteria">The query to expand</param>
            <param name="expandPaths">The names of the properties to expand.  May include nested paths of the form "Property/SubProperty"</param>
            <param name="sessionFactory">Provides the NHibernate metadata for the classes</param>
            <param name="expandMap">If provided, will be populated with the names of the expanded properties for each type.</param>
            <returns></returns>
        </member>
        <member name="T:Breeze.ContextProvider.NH.ExpandTypeMap">
            <summary>
            Keeps track of the types and methods used by a query, so it can control the lazy loaded in the JsonFormatter.
            </summary>
        </member>
        <member name="T:Breeze.ContextProvider.NH.NHExpander">
            <summary>
            Initializes Hibernate proxies and collections prior to serialization.
            This is used to implement the OData $expand operation.
            
            Be sure to set the default_batch_fetch_size property in your NH config file (or Web.config), e.g.
            <![CDATA[
            <property name="default_batch_fetch_size">32</property>
            ]]>
            so that lazy loading happens in batches, instead of one at a time.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHExpander.InitializeList(System.Collections.IEnumerable,System.String[])">
            <summary>
            Cause initialization of properties on the objects in the collection.
            The properties to initialize are specified in the expandPaths.  For example,
            if roots is a collection of Orders, expandPaths might be 
            [ "Customer", "OrderDetails/Product/Supplier" ]
            </summary>
            <param name="roots">Collection of Hibernate-mapped objects</param>
            <param name="expandPaths">properties relative to the roots</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHExpander.InitializeObjectPath(System.Object,System.String[],System.Int32)">
            <summary>
            Recursively forces loading of each Hibernate proxy in the tree that matches an entry in the expandPath.
            </summary>
            <param name="parent">Top-level object containing the properties</param>
            <param name="expandPath">Path of properties to initialize for each type</param>
            <param name="pathIndex">Where we are in the path</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHExpander.SplitPaths(System.String[])">
            <summary>
            Split the strings into their path components.
            E.g. "OrderDetails/Product" becomes [ "OrderDetails", "Product" ]
            </summary>
            <param name="expandPaths"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHInitializer.InitializeList``1(System.Collections.Generic.IEnumerable{``0},System.String[])">
            <summary>
            Recursively forces loading of each NHibernate proxy in the tree that matches an entry in the map.
            </summary>
            <param name="list">Top-level collection of objects</param>
            <param name="expandMap">Properties to initialize for each type</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHInitializer.InitializeList(System.Collections.IEnumerable,Breeze.ContextProvider.NH.ExpandTypeMap)">
            <summary>
            Recursively forces loading of each NHibernate proxy in the tree that matches an entry in the map.
            </summary>
            <param name="list">Top-level collection of objects</param>
            <param name="expandMap">Properties to initialize for each type</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHInitializer.InitializeList(System.Collections.IEnumerable,System.Collections.Generic.IDictionary{System.Type,System.Collections.Generic.List{System.String}},System.Int32)">
            <summary>
            Recursively forces loading of each NHibernate proxy in the tree that matches an entry in the map.
            </summary>
            <param name="list">Top-level collection of objects</param>
            <param name="map">Map of properties to initialize for each type</param>
            <param name="remainingDepth">How deep to follow the tree; prevents infinite looping</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHInitializer.InitializeWithCascade(System.Object,System.Collections.Generic.IDictionary{System.Type,System.Collections.Generic.List{System.String}},System.Int32)">
            <summary>
            Recursively forces loading of each NHibernate proxy in the tree that matches an entry in the map.
            </summary>
            <param name="parent">Top-level object</param>
            <param name="map">Map of properties to initialize for each type</param>
            <param name="remainingDepth">How deep to follow the tree; prevents infinite looping</param>
        </member>
        <member name="T:Breeze.ContextProvider.NH.NHMetadataBuilder">
            <summary>
            Builds a data structure containing the metadata required by Breeze.
            <see cref="!:http://www.breezejs.com/documentation/breeze-metadata-format"/>
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.BuildMetadata">
            <summary>
            Build the Breeze metadata as a nested Dictionary.  
            The result can be converted to JSON and sent to the Breeze client.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.BuildMetadata(System.Func{System.Type,System.Boolean})">
            <summary>
            Build the Breeze metadata as a nested Dictionary.  
            The result can be converted to JSON and sent to the Breeze client.
            </summary>
            <param name="includeFilter">Function that returns true if a Type should be included in metadata, false otherwise</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.BuildMetadata(System.Collections.Generic.IEnumerable{NHibernate.Metadata.IClassMetadata})">
            <summary>
            Build the Breeze metadata as a nested Dictionary.  
            The result can be converted to JSON and sent to the Breeze client.
            </summary>
            <param name="classMeta">Entity metadata types to include in the metadata</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.InitMap">
            <summary>
            Populate the metadata header.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.AddClass(NHibernate.Metadata.IClassMetadata)">
            <summary>
            Add the metadata for an entity.
            </summary>
            <param name="meta"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.AddClassProperties(NHibernate.Metadata.IClassMetadata,System.Collections.Generic.List{System.Collections.Generic.Dictionary{System.String,System.Object}},System.Collections.Generic.List{System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Add the properties for an entity.
            </summary>
            <param name="meta"></param>
            <param name="dataList">will be populated with the data properties of the entity</param>
            <param name="navList">will be populated with the navigation properties of the entity</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.GetSuperProperties(NHibernate.Persister.Entity.AbstractEntityPersister)">
            <summary>
            Return names of all properties that are defined in the mapped ancestors of the 
            given persister.  Note that unmapped superclasses are deliberately ignored, because
            they shouldn't affect the metadata.
            </summary>
            <param name="persister"></param>
            <returns>set of property names.  Empty if the persister doesn't have a superclass.</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.AddComponent(NHibernate.Type.ComponentType,System.String[])">
            <summary>
            Adds a complex type definition
            </summary>
            <param name="compType">The complex type</param>
            <param name="columnNames">The names of the columns which the complex type spans.</param>
            <returns>The class name and namespace of the complex type, in the form "Location:#Breeze.Nhibernate.NorthwindIBModel"</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.MakeDataProperty(Breeze.ContextProvider.NH.IMemberConfiguration,System.String,NHibernate.Type.IType,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Make data property metadata for the entity
            </summary>
            <param name="memberConfiguration">member configuration defined by developer</param>
            <param name="propName">name of the property on the server</param>
            <param name="type">data type of the property, e.g. Int32</param>
            <param name="isNullable">whether the property is nullable in the database</param>
            <param name="isKey">true if this property is part of the key for the entity</param>
            <param name="isVersion">true if this property contains the version of the entity (for a concurrency strategy)</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.MakeAssociationProperty(NHibernate.Persister.Entity.AbstractEntityPersister,NHibernate.Type.IAssociationType,System.String,System.Collections.Generic.List{System.Collections.Generic.Dictionary{System.String,System.Object}},System.Boolean)">
            <summary>
            Make association property metadata for the entity.
            Also populates the ForeignKeyMap which is used for related-entity fixup in NHContext.FixupRelationships
            </summary>
            <param name="containingPersister">Entity Persister containing the property</param>
            <param name="propType">Association property</param>
            <param name="propName">Name of the property</param>
            <param name="dataProperties">Data properties already collected for the containingType.  "isPartOfKey" may be added to a property.</param>
            <param name="isKey">Whether the property is part of the key</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.GetPropertyColumnNames(NHibernate.Persister.Entity.AbstractEntityPersister,System.String,NHibernate.Type.IType)">
            <summary>
            Get the column names for a given property as a comma-delimited string of unbracketed names.
            For a collection property, the column name is the inverse foreign key (i.e. the column on 
            the other table that points back to the persister's table)
            </summary>
            <param name="persister"></param>
            <param name="propertyName"></param>
            <param name="propType"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.GetPropertyNamesForColumns(NHibernate.Persister.Entity.AbstractEntityPersister,System.String[])">
            <summary>
            Gets the properties matching the given columns.  May be a component, but will not be an association.
            </summary>
            <param name="persister"></param>
            <param name="columnNames">Array of column names</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.CatColumnNames(System.String[],System.Char)">
            <summary>
            Unbrackets the column names and concatenates them into a comma-delimited string
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.NamesEqual(System.String[],System.String[])">
            <summary>
            return true if the two arrays contain the same names, false otherwise.
            Names are compared after UnBracket(), and are case-insensitive.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.UnBracket(System.String)">
            <summary>
            Get the column name without square brackets or quotes around it.  E.g. "[OrderID]" -> OrderID
            Because sometimes Hibernate gives us brackets, and sometimes it doesn't.
            Double-quotes happen with SQL CE.  Backticks happen with MySQL.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.UnBracket(System.String[])">
            <summary>
            Return a new array containing the UnBracketed names
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.FindPropertyByName(System.Collections.Generic.List{System.Collections.Generic.Dictionary{System.String,System.Object}},System.String)">
            <summary>
            Find the property in the list that has the given name.
            </summary>
            <param name="properties">list of DataProperty or NavigationProperty maps</param>
            <param name="name">matched against the nameOnServer value of entries in the list</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.GetEntityType(System.Type,System.Boolean)">
            <summary>
            Get the Breeze name of the entity type.
            For collections, Breeze expects the name of the element type.
            </summary>
            <param name="type"></param>
            <param name="isCollectionType"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.Pluralize(System.String)">
            <summary>
            lame pluralizer.  Assumes we just need to add a suffix.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHMetadataBuilder.GetAssociationName(System.String,System.String,System.String[])">
            <summary>
            Creates an association name from two entity names.
            For consistency, puts the entity names in alphabetical order.
            </summary>
            <param name="name1"></param>
            <param name="name2"></param>
            <param name="propType">Used to ensure the association name is unique for a type</param>
            <returns></returns>
        </member>
        <member name="T:Breeze.ContextProvider.NH.NhQueryableInclude`1">
            <summary>
            Extends NhQueryable to add an Include function.  
            
            Include supports the OData $expand implementation, which retrieves related entities by following navigation properties.
            Note that Include is not the same as Fetch.  Fetch performs a join operation, while Include causes as second query.
            Fetch can be faster, but Include preserves the row count sematics of the original query.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NhQueryableInclude`1.#ctor(NHibernate.Engine.ISessionImplementor,System.Boolean)">
            <summary>
            Create a query which may be marked cachable.
            
            Calls the base constructor, setting the Expression using NhQueryable.
            Needed because the NHibernate Linq parser chokes if NhQueryableInclude is in the expression.
            </summary>
            <remarks>Note that some combinations of operations (.Select with .Where) result in errors 
            from the NHibernate LINQ provider when using cacheable queries.</remarks>
            <param name="si">Session</param>
            <param name="cacheable">True to set the query as cachable, false as not cacheable.  Defaults to false.</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NhQueryableInclude`1.#ctor(NHibernate.Engine.ISessionImplementor,System.String)">
            <summary>
            Create a cacheable query using the given cache region.
            
            Calls the base constructor, setting the Expression using NhQueryable.
            Needed because the NHibernate Linq parser chokes if NhQueryableInclude is in the expression.
            </summary>
            <remarks>Note that some combinations of operations (.Select with .Where) result in errors 
            from the NHibernate LINQ provider when using cacheable queries.</remarks>
            <param name="si">Session</param>
            <param name="cacheRegion">Cache Region to use for caching the query.  
            <see cref="!:http://nhforge.org/doc/nh/en/#performance-querycache"/> and
            <see cref="!:http://nhforge.org/doc/nh/en/#caches"/></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Breeze.ContextProvider.NH.NhQueryableInclude`1.Include(System.String)" -->
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.BeforeApplyQuery(System.Linq.IQueryable,System.Web.Http.OData.Query.ODataQueryOptions)">
            <summary>
            Before applying the queryOptions to the queryable, perform special processing to handle
            $expand and work around the NHibernate IQueryable limitations
            </summary>
            <param name="queryable"></param>
            <param name="queryOptions"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.NHApplyExpand(Breeze.ContextProvider.NH.IQueryableInclude)">
            <summary>
            Saves the expand path strings from queryable.GetIncludes(),
            for later lazy initialization and serialization.
            </summary>
            <param name="queryable"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.NHApplyExpand(System.Linq.IQueryable,System.Web.Http.OData.Query.ODataQueryOptions)">
            <summary>
            Saves the expand path string from the queryOptions, 
            for later lazy initialization and serialization.
            </summary>
            <param name="queryable"></param>
            <param name="expandsQueryString"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.ApplyExpand(System.Linq.IQueryable,System.Web.Http.OData.Query.ODataQueryOptions)">
            <summary>
            Override ApplyExpand to do nothing.  NHApplyExpand takes care of expands for NH, and 
            it is executed earlier in the query processing (in BeforeApplyQuery)
            </summary>
            <param name="queryable"></param>
            <param name="queryOptions"></param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.GetSession(System.Linq.IQueryable)">
            <summary>
            Get the ISession from the IQueryable.
            </summary>
            <param name="queryable"></param>
            <returns>the session if queryable.Provider is NHibernate.Linq.DefaultQueryProvider, else null</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.PostExecuteQuery(System.Collections.IEnumerable)">
            <summary>
            Perform the lazy loading allowed in the expandPaths.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.ConfigureFormatter(System.Net.Http.Formatting.JsonMediaTypeFormatter,System.Linq.IQueryable)">
            <summary>
            Configure the JsonFormatter to limit the object serialization of the response.
            Even with no IQueryable, we still need to configure the formatter to prevent runaway serialization.
            We have to rely on the controller to close the session in this case.
            </summary>
            <param name="jsonFormatter"></param>
            <param name="queryable">Used to obtain the ISession</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.ConfigureFormatter(System.Net.Http.Formatting.JsonMediaTypeFormatter,NHibernate.ISession)">
            <summary>
            Configure the JsonFormatter to limit the object serialization of the response.
            </summary>
            <param name="jsonFormatter">request.GetConfiguration().Formatters.JsonFormatter</param>
            <param name="session">If not null, will be closed by this method.  Otherwise, the session must be closed by the Controller.</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.ConfigureFormatterAsync(System.Net.Http.Formatting.JsonMediaTypeFormatter,NHibernate.ISession)">
            <summary>
            Configure the JsonFormatter to limit the object serialization of the response.
            </summary>
            <param name="jsonFormatter">request.GetConfiguration().Formatters.JsonFormatter</param>
            <param name="session">If not null, will be closed by this method.  Otherwise, the session must be closed by the Controller.</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.Close(System.Object)">
            <summary>
            Release any resources associated with this QueryHelper.
            </summary>
            <param name="responseObject">Response payload, which may have associated resources.</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.CloseAsync(System.Object)">
            <summary>
            Release any resources associated with this QueryHelper.
            </summary>
            <param name="responseObject">Response payload, which may have associated resources.</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHQueryHelper.WrapResultAsync(System.Net.Http.HttpRequestMessage,System.Net.Http.HttpResponseMessage,System.Linq.IQueryable)">
            <summary>
            Replaces the response.Content with the query results, wrapped in a QueryResult object if necessary.
            </summary>
            <param name="request"></param>
            <param name="response"></param>
            <param name="queryResult"></param>
        </member>
        <member name="T:Breeze.ContextProvider.NH.NHRelationshipFixer">
            <summary>
            Utility class for re-establishing the relationships between entities prior to saving them in Nhibernate.
            
            Breeze requires many-to-one relationships to have properties both the related entity and its ID, and it 
            sends only the ID in the save bundle.  To make it work with NH, we map the <code>many-to-one</code> entity, and map the 
            foreign key ID with <code> insert="false" update="false" </code>, so the <code>many-to-one</code> entity must
            be populated in order for the foreign key value to be saved in the DB.  To work
            around this problem, this class uses the IDs sent by Breeze to re-connect the related entities.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.#ctor(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{Breeze.ContextProvider.EntityInfo}},System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.ISession,Breeze.ContextProvider.NH.IBreezeConfigurator)">
            <summary>
            Create new instance with the given saveMap and fkMap.  Since the saveMap is unique per save, 
            this instance will be useful for processing one entire save bundle only.
            </summary>
            <param name="saveMap">Map of entity types -> entity instances to save.  This is provided by Breeze in the SaveChanges call.</param>
            <param name="fkMap">Map of relationship name -> foreign key name.  This is built in the NHBreezeMetadata class.</param>
            <param name="session">NHibernate session that will save the entities</param>
            <param name="breezeConfigurator"></param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.FixupRelationships">
            <summary>
            Connect the related entities in the saveMap to other entities.  If the related entities
            are not in the saveMap, they are loaded from the session.
            </summary>
            <returns>The list of entities in the order they should be save, according to their relationships.</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.RemoveRelationships">
            <summary>
            Remove the navigations between entities in the saveMap.  This flattens the JSON
            result so Breeze can handle it.
            </summary>
            <param name="saveMap">Map of entity types -> entity instances to save</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.AddToGraph(Breeze.ContextProvider.EntityInfo,Breeze.ContextProvider.EntityInfo,System.Boolean)">
            <summary>
            Add the relationship to the dependencyGraph
            </summary>
            <param name="child">Entity that depends on parent (e.g. has a many-to-one relationship to parent)</param>
            <param name="parent">Entity that child depends on (e.g. one parent has one-to-many children)</param>
            <param name="removeReverse">True to find and remove the reverse relationship.  Used for handling one-to-ones.</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.SortDependencies">
            <summary>
            Sort the entries in the dependency graph according to their dependencies.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.AddToSaveOrder(Breeze.ContextProvider.EntityInfo,System.Int32)">
            <summary>
            Recursively add entities to the saveOrder or deleteOrder according to their dependencies
            </summary>
            <param name="entityInfo">Entity to be added.  Its dependencies will be added depth-first.</param>
            <param name="depth">prevents infinite recursion in case of cyclic dependencies</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.ProcessRelationships">
            <summary>
            Add or remove the entity relationships according to the removeMode.
            </summary>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.FixupRelationships(Breeze.ContextProvider.EntityInfo,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Connect the related entities based on the foreign key values.
            Note that this may cause related entities to be loaded from the DB if they are not already in the session.
            </summary>
            <param name="entityInfo">Entity that will be saved</param>
            <param name="meta">Metadata about the entity type</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.TryToFindAndLinkBidirectionalRelation(NHibernate.Type.ManyToOneType,NHibernate.Type.EntityType,System.String,Breeze.ContextProvider.EntityInfo,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Find out if a bidirectional relation exists, if exists then add entity to the collection
            </summary>
            <param name="manyToOneType">Many to one relation</param>
            <param name="childEntityType">Entity type of the child</param>
            <param name="propertyName">Property name of the ManyToOne realtion</param>
            <param name="childEntityInfo">Entity info of the child</param>
            <param name="childMeta">Child metadata</param>
            <returns>true if the child entity was added or removed from the parent entity collection, otherwise false</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.FixupComponentRelationships(System.String,NHibernate.Type.ComponentType,Breeze.ContextProvider.EntityInfo,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Connect the related entities based on the foreign key values found in a component type.
            This updates the values of the component's properties.
            </summary>
            <param name="propName">Name of the (component) property of the entity.  May be null if the property is the entity's identifier.</param>
            <param name="compType">Type of the component</param>
            <param name="entityInfo">Breeze EntityInfo</param>
            <param name="meta">Metadata for the entity class</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.FixupRelationship(System.String,NHibernate.Type.EntityType,Breeze.ContextProvider.EntityInfo,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Set an association value based on the value of the foreign key.  This updates the property of the entity.
            </summary>
            <param name="propName">Name of the navigation/association property of the entity, e.g. "Customer".  May be null if the property is the entity's identifier.</param>
            <param name="propType">Type of the property</param>
            <param name="entityInfo">Breeze EntityInfo</param>
            <param name="meta">Metadata for the entity class</param>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.GetRelatedEntity(System.String,NHibernate.Type.EntityType,Breeze.ContextProvider.EntityInfo,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Get a related entity based on the value of the foreign key.  Attempts to find the related entity in the
            saveMap; if its not found there, it is loaded via the Session (which should create a proxy, not actually load 
            the entity from the database).
            Related entities are Promoted in the saveOrder according to their state.
            </summary>
            <param name="propName">Name of the navigation/association property of the entity, e.g. "Customer".  May be null if the property is the entity's identifier.</param>
            <param name="propType">Type of the property</param>
            <param name="entityInfo">Breeze EntityInfo</param>
            <param name="meta">Metadata for the entity class</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.FindForeignKey(System.String,NHibernate.Metadata.IClassMetadata)">
            <summary>
            Find a foreign key matching the given property, by looking in the fkMap.
            The property may be defined on the class or a superclass, so this function calls itself recursively.
            </summary>
            <param name="propName">Name of the property e.g. "Product"</param>
            <param name="meta">Class metadata, for traversing the class hierarchy</param>
            <returns>The name of the foreign key, e.g. "ProductID"</returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.GetForeignKeyValue(Breeze.ContextProvider.EntityInfo,NHibernate.Metadata.IClassMetadata,System.String)">
            <summary>
            Get the value of the foreign key property.  This comes from the entity, but if that value is
            null, and the entity is deleted, we try to get it from the originalValuesMap.
            </summary>
            <param name="entityInfo">Breeze EntityInfo</param>
            <param name="meta">Metadata for the entity class</param>
            <param name="foreignKeyName">Name of the foreign key property of the entity, e.g. "CustomerID"</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.GetPropertyValue(NHibernate.Metadata.IClassMetadata,System.Object,System.String)">
            <summary>
            Return the property value for the given entity.
            </summary>
            <param name="meta"></param>
            <param name="entity"></param>
            <param name="propName">If null, the identifier property will be returned.</param>
            <returns></returns>
        </member>
        <member name="M:Breeze.ContextProvider.NH.NHRelationshipFixer.FindInSaveMap(System.Type,System.Object)">
            <summary>
            Find the matching entity in the saveMap.  This is for relationship fixup.
            </summary>
            <param name="entityType">Type of entity, e.g. Order.  The saveMap will be searched for this type and its subtypes.</param>
            <param name="entityId">Key value of the entity</param>
            <returns>The entity, or null if not found</returns>
        </member>
    </members>
</doc>
